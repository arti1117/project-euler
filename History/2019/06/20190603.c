/*
 * 20190603.c
 *
 *  Created on: Jun 15, 2019
 *      Author: arti
 */

//The four adjacent digits in the 1000-digit number
//that have the greatest product are 9 × 9 × 8 × 9 = 5832.

//73167176531330624919225119674426574742355349194934
//96983520312774506326239578318016984801869478851843
//85861560789112949495459501737958331952853208805511
//12540698747158523863050715693290963295227443043557
//66896648950445244523161731856403098711121722383113
//62229893423380308135336276614282806444486645238749
//30358907296290491560440772390713810515859307960866
//70172427121883998797908792274921901699720888093776
//65727333001053367881220235421809751254540594752243
//52584907711670556013604839586446706324415722155397
//53697817977846174064955149290862569321978468622482
//83972241375657056057490261407972968652414535100474
//82166370484403199890008895243450658541227588666881
//16427171479924442928230863465674813919123162824586
//17866458359124566529476545682848912883142607690042
//24219022671055626321111109370544217506941658960408
//07198403850962455444362981230987879927244284909188
//84580156166097919133875499200524063689912560717606
//05886116467109405077541002256983155200055935729725
//71636269561882670428252483600823257530420752963450

//Find the thirteen adjacent digits in the 1000-digit number
//that have the greatest product. What is the value of this product?

#include "Architects.h"

#define MAX 1000
#define MIN 13

void test()
{
	int member[MAX];

	int i, j, flag=1;
	double front=1111111111111.0;
	double back=1111111111111.0;
//	printf("%d\n", Greatest(9989));

	char digit[] = "73167176531330624919225119674426574742355349194934" \
				   "96983520312774506326239578318016984801869478851843" \
				   "85861560789112949495459501737958331952853208805511" \
				   "12540698747158523863050715693290963295227443043557" \
				   "66896648950445244523161731856403098711121722383113" \
				   "62229893423380308135336276614282806444486645238749" \
				   "30358907296290491560440772390713810515859307960866" \
				   "70172427121883998797908792274921901699720888093776" \
				   "65727333001053367881220235421809751254540594752243" \
				   "52584907711670556013604839586446706324415722155397" \
				   "53697817977846174064955149290862569321978468622482" \
				   "83972241375657056057490261407972968652414535100474" \
				   "82166370484403199890008895243450658541227588666881" \
				   "16427171479924442928230863465674813919123162824586" \
				   "17866458359124566529476545682848912883142607690042" \
				   "24219022671055626321111109370544217506941658960408" \
				   "07198403850962455444362981230987879927244284909188" \
				   "84580156166097919133875499200524063689912560717606" \
				   "05886116467109405077541002256983155200055935729725" \
				   "71636269561882670428252483600823257530420752963450";
	for (i=0; i<MAX; i++) {
		member[i] = digit[i] - '0';
	}

	int jack=0;
	double temp1=0;
	double temp2=0;

	int tmp1[13];
	int tmp2[13];

	double tmp1_res=1;
	double tmp2_res=1;

	int a, b;

	while (flag) {
		temp1 = temp2 = 0;
		a = b = 0;
		for (i=jack;i<MIN+jack;i++) {
			if (member[i] == 0) {
				break;
			}
			temp1 = temp1*10 + member[i];
			tmp1[a] = member[i];
			a++;
		}
		if (temp1 > front) {
			front = temp1;
			tmp1_res = 1;
			for (a=0; a<MIN; a++) {
				tmp1_res *= tmp1[a];
			}
		}
		for (j=MAX-MIN-jack;j<MAX-jack;j++) {
			if (member[j] == 0) {
				break;
			}
			temp2 = temp2*10 + member[j];
			tmp2[b] = member[j];
			b++;
		}
		if (temp2 > back) {
			back = temp2;
			tmp2_res = 1;
			for (b=0; b<MIN; b++) {
				tmp2_res *= tmp2[b];
			}
		}
		if (front == back && tmp1_res == tmp2_res) {
			flag--;
		}
		jack++;
	}

	printf("Front: %f, Back: %f\n", front, back);
	printf("The Greatest product is %f\n", tmp1_res);

}


